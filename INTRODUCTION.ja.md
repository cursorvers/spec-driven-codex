# INTRODUCTION.md

こんにちは、とまだです。

本ドキュメントでは仕様駆動開発、そして本OSS「Spec Driven Codex」について初心者向けに解説しています。

AIとのペアプログラミング、楽しいですよね。

しかし、こんな経験はありませんか？

「Claude Codeに任せていたら、いつの間にか全然違う方向に実装が進んでいた」

「仕様が曖昧なままコーディングに入って、後から大きな手戻りが発生した」

今回は、そんな悩みを解決するOSSツール「spec-driven-codex」を紹介します。

私自身、AIペアプログラミングで複数のプロジェクトを開発してきましたが、この手法を導入してから開発の見通しが劇的に改善しました。

## 忙しい人のために要約

- AIペアプログラミングに仕様駆動開発の考え方を導入するツール
- たった1コマンドで開発プロセスの枠組みが整う
- 要件→設計→実装の流れで、AIの暴走を防ぎながら生産性を最大化
- 高速モードで設計から実装まで一気に進めることも可能

## AIペアプログラミングの落とし穴

AIとのペアプログラミングは確かに生産性を爆上げしてくれます。

ですが、同時に新しい課題も生まれています。

たとえば、AIが提案したコードをそのまま受け入れていたら、いつの間にか全体の構成がめちゃくちゃになっていたり。

または、要件が曖昧なまま「とりあえず作って」とAIに指示したら、後から「これじゃない」となって大幅な修正が必要になったり。

これらの問題の根本原因は、**仕様が明確でないまま実装に入ること**です。

人間同士の開発でも同じですが、AIとの開発では特にこの問題が顕著になります。

なぜなら、AIは指示に従順すぎるから。

曖昧な指示でも「とりあえず何か作る」ので、一見進捗があるように見えてしまうんです。

## 仕様駆動開発という解決策

spec-driven-codexは、この問題に対して「仕様駆動開発（SDD）」という古典的かつ実績のある手法を採用しています。

仕様駆動開発とは、簡単に言えば「作るものを明確にしてから作り始める」という当たり前のアプローチです。

しかし、AIペアプログラミングの文脈では、この当たり前のことが革新的な意味を持ちます。

要件定義→設計→実装という流れの**各段階で人間の承認を挟む**ことで、AIの生産性を活かしつつ、方向性のブレを防げるからです。

## 1分で始められる導入方法

導入の簡単さが、このツールの大きな魅力です。

```bash
# 日本語版でインストール
npx spec-driven-codex init --locale ja
```

このコマンド一つで、以下が自動的に整います：

- `.sdd/` ディレクトリ構造の作成
- Codex CLI用の7つのプロンプト配置
- 機能説明テンプレートの準備

既存プロジェクトでも、新規プロジェクトでも、すぐに使い始められます。

設定ファイルの編集も、複雑な環境構築も必要ありません。

## 6つのステップで進む開発フロー

spec-driven-codexが提供する開発フローは、6つのステップから構成されています。

### 1. Steering（舵取り）

既存プロジェクトの場合、まず全体像を把握します。

```bash
codex
> /sdd-steering
```

このコマンドで、プロジェクトの概要、技術スタック、ファイル構造の3つのドキュメントが自動生成されます。

AIがプロジェクトの「記憶」を持つことで、以降の開発がスムーズに進みます。

### 2. Requirements（要件定義）

次に、作りたい機能の要件を明確にします。

```bash
# 機能の説明を書く
echo "ユーザー認証機能を追加したい" > .sdd/description.md

# 要件を詰める
> /sdd-requirements
```

ここでは、機能の詳細な要件と受入基準が定義されます。

「完成」の定義が曖昧になることを防ぐ重要なステップです。

### 3. Design（設計）

要件が固まったら、設計に移ります。

```bash
> /sdd-design
```

アーキテクチャ、データフロー、エラーハンドリングなど、実装前に考えるべきことをすべて明文化します。

既存コードとの統合方法も、この段階で検討されます。

### 4. Tasks（タスク分解）

設計を基に、実装可能な粒度にタスクを分解します。

```bash
> /sdd-tasks
```

チェックリスト形式でタスクが整理され、進捗が一目で分かるようになります。

### 5. Implementation（実装）

いよいよ実装です。

```bash
> /sdd-implement
```

タスクを順番に実行し、テストファーストで品質を担保しながら進めます。

### 6. Archive（アーカイブ）

完成したら、仕様を日付付きでアーカイブします。

```bash
> /sdd-archive
```

これにより、プロジェクトの知識が蓄積され、将来の開発に活かせます。

## 高速モードで開発を加速

要件が明確な場合は、「Highway（高速）モード」が便利です。

```bash
> /sdd-highway
```

このコマンドで、設計→タスク分解→実装までを一気に進められます。

要件定義に集中したい場合や、迅速にプロトタイプを作りたい場合に最適です。

ただし、高速モードでも各ステップでの承認は求められるので、暴走の心配はありません。

## 実際の使用感

実際にこのツールを使ってみると、開発の見通しが格段に良くなることを実感します。

たとえば、「ユーザー認証機能を追加」という要件から始めた場合。

従来のAIペアプログラミングでは、いきなりコード生成が始まり、後から「あ、これも必要だった」となることが多かったです。

しかしspec-driven-codexを使うと、要件定義の段階で「パスワードリセット機能は？」「ソーシャルログインは？」といった考慮漏れが明らかになります。

設計フェーズでは、既存のルーティングとの統合方法や、セッション管理の方針が明確になります。

結果として、手戻りが減り、全体的な開発時間が短縮されました。

## 成果物の管理も簡潔

すべての成果物は`.sdd/`ディレクトリに整理されます。

```
.sdd/
├── description.md        # 現在作業中の機能説明
├── steering/            # プロジェクトの全体情報
│   ├── product.md
│   ├── tech.md
│   └── structure.md
└── specs/              # 各機能の仕様書
    ├── user-auth/      # ユーザー認証機能
    │   ├── requirements.md
    │   ├── design.md
    │   └── tasks.md
    └── archives/       # 完了済み仕様
```

Gitで管理されるので、チーム開発でも仕様の共有が簡単です。

また、過去の仕様を参照することで、類似機能の開発時に知見を再利用できます。

## まとめ

spec-driven-codexは、AIペアプログラミングに秩序をもたらすシンプルなフレームワークです。

複雑な設定は不要で、既存のワークフローを大きく変える必要もありません。

ただ、要件→設計→実装という当たり前の流れを守るだけ。

それだけで、AIの生産性を最大限に活かしながら、品質の高いコードを生み出せるようになります。

AIとの開発で「なんか違う方向に進んでる気がする」と感じたことがある方は、ぜひ試してみてください。

```bash
npx spec-driven-codex init --locale ja
```

このコマンド一つで、より予測可能で、より品質の高い開発体験が始まります。

---

**リポジトリ**: [github.com/tomada1114/spec-driven-codex](https://github.com/tomada1114/spec-driven-codex)
**ライセンス**: MIT
**お問い合わせ**: [X @muscle_coding](https://x.com/muscle_coding)
